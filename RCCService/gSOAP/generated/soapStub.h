/* soapStub.h
   Generated by gSOAP 2.7.10 from generated/prototypes.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__LuaType
#define SOAP_TYPE_ns1__LuaType (50)
/* ns1:LuaType */
enum ns1__LuaType {ns1__LuaType__LUA_USCORETNIL = 0, ns1__LuaType__LUA_USCORETBOOLEAN = 1, ns1__LuaType__LUA_USCORETNUMBER = 2, ns1__LuaType__LUA_USCORETSTRING = 3, ns1__LuaType__LUA_USCORETTABLE = 4};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (8)
/* ns1:Status */
class SOAP_CMAC ns1__Status
{
public:
	std::string *version;	/* optional element of type xsd:string */
	int environmentCount;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__Status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Status() : version(NULL), environmentCount(0), soap(NULL) { }
	virtual ~ns1__Status() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Job
#define SOAP_TYPE_ns1__Job (9)
/* ns1:Job */
class SOAP_CMAC ns1__Job
{
public:
	std::string id;	/* required element of type xsd:string */
	double expirationInSeconds;	/* required element of type xsd:double */
	int category;	/* required element of type xsd:int */
	double cores;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__Job */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Job() : expirationInSeconds(0), category(0), cores(0), soap(NULL) { }
	virtual ~ns1__Job() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ScriptExecution
#define SOAP_TYPE_ns1__ScriptExecution (10)
/* ns1:ScriptExecution */
class SOAP_CMAC ns1__ScriptExecution
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::string *script;	/* optional element of type xsd:string */
	class ns1__ArrayOfLuaValue *arguments;	/* optional element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__ScriptExecution */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ScriptExecution() : name(NULL), script(NULL), arguments(NULL), soap(NULL) { }
	virtual ~ns1__ScriptExecution() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfLuaValue
#define SOAP_TYPE_ns1__ArrayOfLuaValue (11)
/* ns1:ArrayOfLuaValue */
class SOAP_CMAC ns1__ArrayOfLuaValue
{
public:
	std::vector<class ns1__LuaValue * >LuaValue;	/* optional element of type ns1:LuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__ArrayOfLuaValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfLuaValue() : soap(NULL) { }
	virtual ~ns1__ArrayOfLuaValue() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfJob
#define SOAP_TYPE_ns1__ArrayOfJob (12)
/* ns1:ArrayOfJob */
class SOAP_CMAC ns1__ArrayOfJob
{
public:
	std::vector<ns1__Job * >Job;	/* optional element of type ns1:Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__ArrayOfJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfJob() : soap(NULL) { }
	virtual ~ns1__ArrayOfJob() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LuaValue
#define SOAP_TYPE_ns1__LuaValue (13)
/* ns1:LuaValue */
class SOAP_CMAC ns1__LuaValue
{
public:
	enum ns1__LuaType type;	/* required element of type ns1:LuaType */
	std::string *value;	/* optional element of type xsd:string */
	ns1__ArrayOfLuaValue *table;	/* optional element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__LuaValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LuaValue() : type((enum ns1__LuaType)0), value(NULL), table(NULL), soap(NULL) { }
	virtual ~ns1__LuaValue() { }
};
#endif

#ifndef SOAP_TYPE__ns1__HelloWorld
#define SOAP_TYPE__ns1__HelloWorld (14)
/* ns1:HelloWorld */
class SOAP_CMAC _ns1__HelloWorld
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE__ns1__HelloWorld */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__HelloWorld() : soap(NULL) { }
	virtual ~_ns1__HelloWorld() { }
};
#endif

#ifndef SOAP_TYPE__ns1__HelloWorldResponse
#define SOAP_TYPE__ns1__HelloWorldResponse (15)
/* ns1:HelloWorldResponse */
class SOAP_CMAC _ns1__HelloWorldResponse
{
public:
	std::string *HelloWorldResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE__ns1__HelloWorldResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__HelloWorldResponse() : HelloWorldResult(NULL), soap(NULL) { }
	virtual ~_ns1__HelloWorldResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVersion
#define SOAP_TYPE__ns1__GetVersion (16)
/* ns1:GetVersion */
class SOAP_CMAC _ns1__GetVersion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE__ns1__GetVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVersion() : soap(NULL) { }
	virtual ~_ns1__GetVersion() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVersionResponse
#define SOAP_TYPE__ns1__GetVersionResponse (17)
/* ns1:GetVersionResponse */
class SOAP_CMAC _ns1__GetVersionResponse
{
public:
	std::string GetVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE__ns1__GetVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVersionResponse() : soap(NULL) { }
	virtual ~_ns1__GetVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStatus
#define SOAP_TYPE__ns1__GetStatus (18)
/* ns1:GetStatus */
class SOAP_CMAC _ns1__GetStatus
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__ns1__GetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStatus() : soap(NULL) { }
	virtual ~_ns1__GetStatus() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStatusResponse
#define SOAP_TYPE__ns1__GetStatusResponse (19)
/* ns1:GetStatusResponse */
class SOAP_CMAC _ns1__GetStatusResponse
{
public:
	ns1__Status *GetStatusResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__ns1__GetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStatusResponse() : GetStatusResult(NULL), soap(NULL) { }
	virtual ~_ns1__GetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OpenJob
#define SOAP_TYPE__ns1__OpenJob (20)
/* ns1:OpenJob */
class SOAP_CMAC _ns1__OpenJob
{
public:
	ns1__Job *job;	/* required element of type ns1:Job */
	ns1__ScriptExecution *script;	/* optional element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__ns1__OpenJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OpenJob() : job(NULL), script(NULL), soap(NULL) { }
	virtual ~_ns1__OpenJob() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OpenJobEx
#define SOAP_TYPE__ns1__OpenJobEx (21)
/* ns1:OpenJobEx */
class SOAP_CMAC _ns1__OpenJobEx
{
public:
	ns1__Job *job;	/* required element of type ns1:Job */
	ns1__ScriptExecution *script;	/* optional element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__ns1__OpenJobEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OpenJobEx() : job(NULL), script(NULL), soap(NULL) { }
	virtual ~_ns1__OpenJobEx() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OpenJobResponse
#define SOAP_TYPE__ns1__OpenJobResponse (22)
/* ns1:OpenJobResponse */
class SOAP_CMAC _ns1__OpenJobResponse
{
public:
	std::vector<ns1__LuaValue * >OpenJobResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:LuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__ns1__OpenJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OpenJobResponse() : soap(NULL) { }
	virtual ~_ns1__OpenJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__OpenJobExResponse
#define SOAP_TYPE__ns1__OpenJobExResponse (23)
/* ns1:OpenJobExResponse */
class SOAP_CMAC _ns1__OpenJobExResponse
{
public:
	ns1__ArrayOfLuaValue *OpenJobExResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__ns1__OpenJobExResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__OpenJobExResponse() : OpenJobExResult(NULL), soap(NULL) { }
	virtual ~_ns1__OpenJobExResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RenewLease
#define SOAP_TYPE__ns1__RenewLease (24)
/* ns1:RenewLease */
class SOAP_CMAC _ns1__RenewLease
{
public:
	std::string jobID;	/* required element of type xsd:string */
	double expirationInSeconds;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__ns1__RenewLease */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RenewLease() : expirationInSeconds(0), soap(NULL) { }
	virtual ~_ns1__RenewLease() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RenewLeaseResponse
#define SOAP_TYPE__ns1__RenewLeaseResponse (25)
/* ns1:RenewLeaseResponse */
class SOAP_CMAC _ns1__RenewLeaseResponse
{
public:
	double RenewLeaseResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__ns1__RenewLeaseResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RenewLeaseResponse() : RenewLeaseResult(0), soap(NULL) { }
	virtual ~_ns1__RenewLeaseResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Execute
#define SOAP_TYPE__ns1__Execute (26)
/* ns1:Execute */
class SOAP_CMAC _ns1__Execute
{
public:
	std::string jobID;	/* required element of type xsd:string */
	ns1__ScriptExecution *script;	/* required element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__ns1__Execute */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Execute() : script(NULL), soap(NULL) { }
	virtual ~_ns1__Execute() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ExecuteResponse
#define SOAP_TYPE__ns1__ExecuteResponse (27)
/* ns1:ExecuteResponse */
class SOAP_CMAC _ns1__ExecuteResponse
{
public:
	std::vector<ns1__LuaValue * >ExecuteResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:LuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__ns1__ExecuteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ExecuteResponse() : soap(NULL) { }
	virtual ~_ns1__ExecuteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ExecuteEx
#define SOAP_TYPE__ns1__ExecuteEx (28)
/* ns1:ExecuteEx */
class SOAP_CMAC _ns1__ExecuteEx
{
public:
	std::string jobID;	/* required element of type xsd:string */
	ns1__ScriptExecution *script;	/* required element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__ns1__ExecuteEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ExecuteEx() : script(NULL), soap(NULL) { }
	virtual ~_ns1__ExecuteEx() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ExecuteExResponse
#define SOAP_TYPE__ns1__ExecuteExResponse (29)
/* ns1:ExecuteExResponse */
class SOAP_CMAC _ns1__ExecuteExResponse
{
public:
	ns1__ArrayOfLuaValue *ExecuteExResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__ns1__ExecuteExResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ExecuteExResponse() : ExecuteExResult(NULL), soap(NULL) { }
	virtual ~_ns1__ExecuteExResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseJob
#define SOAP_TYPE__ns1__CloseJob (30)
/* ns1:CloseJob */
class SOAP_CMAC _ns1__CloseJob
{
public:
	std::string jobID;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__ns1__CloseJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseJob() : soap(NULL) { }
	virtual ~_ns1__CloseJob() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseJobResponse
#define SOAP_TYPE__ns1__CloseJobResponse (31)
/* ns1:CloseJobResponse */
class SOAP_CMAC _ns1__CloseJobResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__ns1__CloseJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseJobResponse() : soap(NULL) { }
	virtual ~_ns1__CloseJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BatchJob
#define SOAP_TYPE__ns1__BatchJob (32)
/* ns1:BatchJob */
class SOAP_CMAC _ns1__BatchJob
{
public:
	ns1__Job *job;	/* required element of type ns1:Job */
	ns1__ScriptExecution *script;	/* required element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__ns1__BatchJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BatchJob() : job(NULL), script(NULL), soap(NULL) { }
	virtual ~_ns1__BatchJob() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BatchJobResponse
#define SOAP_TYPE__ns1__BatchJobResponse (33)
/* ns1:BatchJobResponse */
class SOAP_CMAC _ns1__BatchJobResponse
{
public:
	std::vector<ns1__LuaValue * >BatchJobResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:LuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__ns1__BatchJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BatchJobResponse() : soap(NULL) { }
	virtual ~_ns1__BatchJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BatchJobEx
#define SOAP_TYPE__ns1__BatchJobEx (34)
/* ns1:BatchJobEx */
class SOAP_CMAC _ns1__BatchJobEx
{
public:
	ns1__Job *job;	/* required element of type ns1:Job */
	ns1__ScriptExecution *script;	/* required element of type ns1:ScriptExecution */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__ns1__BatchJobEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BatchJobEx() : job(NULL), script(NULL), soap(NULL) { }
	virtual ~_ns1__BatchJobEx() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BatchJobExResponse
#define SOAP_TYPE__ns1__BatchJobExResponse (35)
/* ns1:BatchJobExResponse */
class SOAP_CMAC _ns1__BatchJobExResponse
{
public:
	ns1__ArrayOfLuaValue *BatchJobExResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__ns1__BatchJobExResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BatchJobExResponse() : BatchJobExResult(NULL), soap(NULL) { }
	virtual ~_ns1__BatchJobExResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetExpiration
#define SOAP_TYPE__ns1__GetExpiration (36)
/* ns1:GetExpiration */
class SOAP_CMAC _ns1__GetExpiration
{
public:
	std::string jobID;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__ns1__GetExpiration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetExpiration() : soap(NULL) { }
	virtual ~_ns1__GetExpiration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetExpirationResponse
#define SOAP_TYPE__ns1__GetExpirationResponse (37)
/* ns1:GetExpirationResponse */
class SOAP_CMAC _ns1__GetExpirationResponse
{
public:
	double GetExpirationResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__ns1__GetExpirationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetExpirationResponse() : GetExpirationResult(0), soap(NULL) { }
	virtual ~_ns1__GetExpirationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAllJobs
#define SOAP_TYPE__ns1__GetAllJobs (38)
/* ns1:GetAllJobs */
class SOAP_CMAC _ns1__GetAllJobs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__ns1__GetAllJobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAllJobs() : soap(NULL) { }
	virtual ~_ns1__GetAllJobs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAllJobsResponse
#define SOAP_TYPE__ns1__GetAllJobsResponse (39)
/* ns1:GetAllJobsResponse */
class SOAP_CMAC _ns1__GetAllJobsResponse
{
public:
	std::vector<ns1__Job * >GetAllJobsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Job */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__ns1__GetAllJobsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAllJobsResponse() : soap(NULL) { }
	virtual ~_ns1__GetAllJobsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAllJobsEx
#define SOAP_TYPE__ns1__GetAllJobsEx (40)
/* ns1:GetAllJobsEx */
class SOAP_CMAC _ns1__GetAllJobsEx
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__ns1__GetAllJobsEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAllJobsEx() : soap(NULL) { }
	virtual ~_ns1__GetAllJobsEx() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAllJobsExResponse
#define SOAP_TYPE__ns1__GetAllJobsExResponse (41)
/* ns1:GetAllJobsExResponse */
class SOAP_CMAC _ns1__GetAllJobsExResponse
{
public:
	ns1__ArrayOfJob *GetAllJobsExResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ArrayOfJob */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__ns1__GetAllJobsExResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAllJobsExResponse() : GetAllJobsExResult(NULL), soap(NULL) { }
	virtual ~_ns1__GetAllJobsExResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseExpiredJobs
#define SOAP_TYPE__ns1__CloseExpiredJobs (42)
/* ns1:CloseExpiredJobs */
class SOAP_CMAC _ns1__CloseExpiredJobs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__ns1__CloseExpiredJobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseExpiredJobs() : soap(NULL) { }
	virtual ~_ns1__CloseExpiredJobs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseExpiredJobsResponse
#define SOAP_TYPE__ns1__CloseExpiredJobsResponse (43)
/* ns1:CloseExpiredJobsResponse */
class SOAP_CMAC _ns1__CloseExpiredJobsResponse
{
public:
	int CloseExpiredJobsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__CloseExpiredJobsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseExpiredJobsResponse() : CloseExpiredJobsResult(0), soap(NULL) { }
	virtual ~_ns1__CloseExpiredJobsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseAllJobs
#define SOAP_TYPE__ns1__CloseAllJobs (44)
/* ns1:CloseAllJobs */
class SOAP_CMAC _ns1__CloseAllJobs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__CloseAllJobs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseAllJobs() : soap(NULL) { }
	virtual ~_ns1__CloseAllJobs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CloseAllJobsResponse
#define SOAP_TYPE__ns1__CloseAllJobsResponse (45)
/* ns1:CloseAllJobsResponse */
class SOAP_CMAC _ns1__CloseAllJobsResponse
{
public:
	int CloseAllJobsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__CloseAllJobsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CloseAllJobsResponse() : CloseAllJobsResult(0), soap(NULL) { }
	virtual ~_ns1__CloseAllJobsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Diag
#define SOAP_TYPE__ns1__Diag (46)
/* ns1:Diag */
class SOAP_CMAC _ns1__Diag
{
public:
	int type;	/* required element of type xsd:int */
	std::string *jobID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__Diag */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Diag() : type(0), jobID(NULL), soap(NULL) { }
	virtual ~_ns1__Diag() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DiagResponse
#define SOAP_TYPE__ns1__DiagResponse (47)
/* ns1:DiagResponse */
class SOAP_CMAC _ns1__DiagResponse
{
public:
	std::vector<ns1__LuaValue * >DiagResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:LuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__DiagResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DiagResponse() : soap(NULL) { }
	virtual ~_ns1__DiagResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DiagEx
#define SOAP_TYPE__ns1__DiagEx (48)
/* ns1:DiagEx */
class SOAP_CMAC _ns1__DiagEx
{
public:
	int type;	/* required element of type xsd:int */
	std::string *jobID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__DiagEx */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DiagEx() : type(0), jobID(NULL), soap(NULL) { }
	virtual ~_ns1__DiagEx() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DiagExResponse
#define SOAP_TYPE__ns1__DiagExResponse (49)
/* ns1:DiagExResponse */
class SOAP_CMAC _ns1__DiagExResponse
{
public:
	ns1__ArrayOfLuaValue *DiagExResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:ArrayOfLuaValue */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__DiagExResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DiagExResponse() : DiagExResult(NULL), soap(NULL) { }
	virtual ~_ns1__DiagExResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns2__HelloWorld
#define SOAP_TYPE___ns2__HelloWorld (66)
/* Operation wrapper: */
struct __ns2__HelloWorld
{
public:
	_ns1__HelloWorld *ns1__HelloWorld;	/* optional element of type ns1:HelloWorld */
};
#endif

#ifndef SOAP_TYPE___ns2__GetVersion
#define SOAP_TYPE___ns2__GetVersion (70)
/* Operation wrapper: */
struct __ns2__GetVersion
{
public:
	_ns1__GetVersion *ns1__GetVersion;	/* optional element of type ns1:GetVersion */
};
#endif

#ifndef SOAP_TYPE___ns2__GetStatus
#define SOAP_TYPE___ns2__GetStatus (74)
/* Operation wrapper: */
struct __ns2__GetStatus
{
public:
	_ns1__GetStatus *ns1__GetStatus;	/* optional element of type ns1:GetStatus */
};
#endif

#ifndef SOAP_TYPE___ns2__OpenJob
#define SOAP_TYPE___ns2__OpenJob (78)
/* Operation wrapper: */
struct __ns2__OpenJob
{
public:
	_ns1__OpenJob *ns1__OpenJob;	/* optional element of type ns1:OpenJob */
};
#endif

#ifndef SOAP_TYPE___ns2__OpenJobEx
#define SOAP_TYPE___ns2__OpenJobEx (82)
/* Operation wrapper: */
struct __ns2__OpenJobEx
{
public:
	_ns1__OpenJobEx *ns1__OpenJobEx;	/* optional element of type ns1:OpenJobEx */
};
#endif

#ifndef SOAP_TYPE___ns2__RenewLease
#define SOAP_TYPE___ns2__RenewLease (86)
/* Operation wrapper: */
struct __ns2__RenewLease
{
public:
	_ns1__RenewLease *ns1__RenewLease;	/* optional element of type ns1:RenewLease */
};
#endif

#ifndef SOAP_TYPE___ns2__Execute
#define SOAP_TYPE___ns2__Execute (90)
/* Operation wrapper: */
struct __ns2__Execute
{
public:
	_ns1__Execute *ns1__Execute;	/* optional element of type ns1:Execute */
};
#endif

#ifndef SOAP_TYPE___ns2__ExecuteEx
#define SOAP_TYPE___ns2__ExecuteEx (94)
/* Operation wrapper: */
struct __ns2__ExecuteEx
{
public:
	_ns1__ExecuteEx *ns1__ExecuteEx;	/* optional element of type ns1:ExecuteEx */
};
#endif

#ifndef SOAP_TYPE___ns2__CloseJob
#define SOAP_TYPE___ns2__CloseJob (98)
/* Operation wrapper: */
struct __ns2__CloseJob
{
public:
	_ns1__CloseJob *ns1__CloseJob;	/* optional element of type ns1:CloseJob */
};
#endif

#ifndef SOAP_TYPE___ns2__BatchJob
#define SOAP_TYPE___ns2__BatchJob (102)
/* Operation wrapper: */
struct __ns2__BatchJob
{
public:
	_ns1__BatchJob *ns1__BatchJob;	/* optional element of type ns1:BatchJob */
};
#endif

#ifndef SOAP_TYPE___ns2__BatchJobEx
#define SOAP_TYPE___ns2__BatchJobEx (106)
/* Operation wrapper: */
struct __ns2__BatchJobEx
{
public:
	_ns1__BatchJobEx *ns1__BatchJobEx;	/* optional element of type ns1:BatchJobEx */
};
#endif

#ifndef SOAP_TYPE___ns2__GetExpiration
#define SOAP_TYPE___ns2__GetExpiration (110)
/* Operation wrapper: */
struct __ns2__GetExpiration
{
public:
	_ns1__GetExpiration *ns1__GetExpiration;	/* optional element of type ns1:GetExpiration */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAllJobs
#define SOAP_TYPE___ns2__GetAllJobs (114)
/* Operation wrapper: */
struct __ns2__GetAllJobs
{
public:
	_ns1__GetAllJobs *ns1__GetAllJobs;	/* optional element of type ns1:GetAllJobs */
};
#endif

#ifndef SOAP_TYPE___ns2__GetAllJobsEx
#define SOAP_TYPE___ns2__GetAllJobsEx (118)
/* Operation wrapper: */
struct __ns2__GetAllJobsEx
{
public:
	_ns1__GetAllJobsEx *ns1__GetAllJobsEx;	/* optional element of type ns1:GetAllJobsEx */
};
#endif

#ifndef SOAP_TYPE___ns2__CloseExpiredJobs
#define SOAP_TYPE___ns2__CloseExpiredJobs (122)
/* Operation wrapper: */
struct __ns2__CloseExpiredJobs
{
public:
	_ns1__CloseExpiredJobs *ns1__CloseExpiredJobs;	/* optional element of type ns1:CloseExpiredJobs */
};
#endif

#ifndef SOAP_TYPE___ns2__CloseAllJobs
#define SOAP_TYPE___ns2__CloseAllJobs (126)
/* Operation wrapper: */
struct __ns2__CloseAllJobs
{
public:
	_ns1__CloseAllJobs *ns1__CloseAllJobs;	/* optional element of type ns1:CloseAllJobs */
};
#endif

#ifndef SOAP_TYPE___ns2__Diag
#define SOAP_TYPE___ns2__Diag (130)
/* Operation wrapper: */
struct __ns2__Diag
{
public:
	_ns1__Diag *ns1__Diag;	/* optional element of type ns1:Diag */
};
#endif

#ifndef SOAP_TYPE___ns2__DiagEx
#define SOAP_TYPE___ns2__DiagEx (134)
/* Operation wrapper: */
struct __ns2__DiagEx
{
public:
	_ns1__DiagEx *ns1__DiagEx;	/* optional element of type ns1:DiagEx */
};
#endif

#ifndef SOAP_TYPE___ns3__HelloWorld
#define SOAP_TYPE___ns3__HelloWorld (136)
/* Operation wrapper: */
struct __ns3__HelloWorld
{
public:
	_ns1__HelloWorld *ns1__HelloWorld;	/* optional element of type ns1:HelloWorld */
};
#endif

#ifndef SOAP_TYPE___ns3__GetVersion
#define SOAP_TYPE___ns3__GetVersion (138)
/* Operation wrapper: */
struct __ns3__GetVersion
{
public:
	_ns1__GetVersion *ns1__GetVersion;	/* optional element of type ns1:GetVersion */
};
#endif

#ifndef SOAP_TYPE___ns3__GetStatus
#define SOAP_TYPE___ns3__GetStatus (140)
/* Operation wrapper: */
struct __ns3__GetStatus
{
public:
	_ns1__GetStatus *ns1__GetStatus;	/* optional element of type ns1:GetStatus */
};
#endif

#ifndef SOAP_TYPE___ns3__OpenJob
#define SOAP_TYPE___ns3__OpenJob (142)
/* Operation wrapper: */
struct __ns3__OpenJob
{
public:
	_ns1__OpenJob *ns1__OpenJob;	/* optional element of type ns1:OpenJob */
};
#endif

#ifndef SOAP_TYPE___ns3__OpenJobEx
#define SOAP_TYPE___ns3__OpenJobEx (144)
/* Operation wrapper: */
struct __ns3__OpenJobEx
{
public:
	_ns1__OpenJobEx *ns1__OpenJobEx;	/* optional element of type ns1:OpenJobEx */
};
#endif

#ifndef SOAP_TYPE___ns3__RenewLease
#define SOAP_TYPE___ns3__RenewLease (146)
/* Operation wrapper: */
struct __ns3__RenewLease
{
public:
	_ns1__RenewLease *ns1__RenewLease;	/* optional element of type ns1:RenewLease */
};
#endif

#ifndef SOAP_TYPE___ns3__Execute
#define SOAP_TYPE___ns3__Execute (148)
/* Operation wrapper: */
struct __ns3__Execute
{
public:
	_ns1__Execute *ns1__Execute;	/* optional element of type ns1:Execute */
};
#endif

#ifndef SOAP_TYPE___ns3__ExecuteEx
#define SOAP_TYPE___ns3__ExecuteEx (150)
/* Operation wrapper: */
struct __ns3__ExecuteEx
{
public:
	_ns1__ExecuteEx *ns1__ExecuteEx;	/* optional element of type ns1:ExecuteEx */
};
#endif

#ifndef SOAP_TYPE___ns3__CloseJob
#define SOAP_TYPE___ns3__CloseJob (152)
/* Operation wrapper: */
struct __ns3__CloseJob
{
public:
	_ns1__CloseJob *ns1__CloseJob;	/* optional element of type ns1:CloseJob */
};
#endif

#ifndef SOAP_TYPE___ns3__BatchJob
#define SOAP_TYPE___ns3__BatchJob (154)
/* Operation wrapper: */
struct __ns3__BatchJob
{
public:
	_ns1__BatchJob *ns1__BatchJob;	/* optional element of type ns1:BatchJob */
};
#endif

#ifndef SOAP_TYPE___ns3__BatchJobEx
#define SOAP_TYPE___ns3__BatchJobEx (156)
/* Operation wrapper: */
struct __ns3__BatchJobEx
{
public:
	_ns1__BatchJobEx *ns1__BatchJobEx;	/* optional element of type ns1:BatchJobEx */
};
#endif

#ifndef SOAP_TYPE___ns3__GetExpiration
#define SOAP_TYPE___ns3__GetExpiration (158)
/* Operation wrapper: */
struct __ns3__GetExpiration
{
public:
	_ns1__GetExpiration *ns1__GetExpiration;	/* optional element of type ns1:GetExpiration */
};
#endif

#ifndef SOAP_TYPE___ns3__GetAllJobs
#define SOAP_TYPE___ns3__GetAllJobs (160)
/* Operation wrapper: */
struct __ns3__GetAllJobs
{
public:
	_ns1__GetAllJobs *ns1__GetAllJobs;	/* optional element of type ns1:GetAllJobs */
};
#endif

#ifndef SOAP_TYPE___ns3__GetAllJobsEx
#define SOAP_TYPE___ns3__GetAllJobsEx (162)
/* Operation wrapper: */
struct __ns3__GetAllJobsEx
{
public:
	_ns1__GetAllJobsEx *ns1__GetAllJobsEx;	/* optional element of type ns1:GetAllJobsEx */
};
#endif

#ifndef SOAP_TYPE___ns3__CloseExpiredJobs
#define SOAP_TYPE___ns3__CloseExpiredJobs (164)
/* Operation wrapper: */
struct __ns3__CloseExpiredJobs
{
public:
	_ns1__CloseExpiredJobs *ns1__CloseExpiredJobs;	/* optional element of type ns1:CloseExpiredJobs */
};
#endif

#ifndef SOAP_TYPE___ns3__CloseAllJobs
#define SOAP_TYPE___ns3__CloseAllJobs (166)
/* Operation wrapper: */
struct __ns3__CloseAllJobs
{
public:
	_ns1__CloseAllJobs *ns1__CloseAllJobs;	/* optional element of type ns1:CloseAllJobs */
};
#endif

#ifndef SOAP_TYPE___ns3__Diag
#define SOAP_TYPE___ns3__Diag (168)
/* Operation wrapper: */
struct __ns3__Diag
{
public:
	_ns1__Diag *ns1__Diag;	/* optional element of type ns1:Diag */
};
#endif

#ifndef SOAP_TYPE___ns3__DiagEx
#define SOAP_TYPE___ns3__DiagEx (170)
/* Operation wrapper: */
struct __ns3__DiagEx
{
public:
	_ns1__DiagEx *ns1__DiagEx;	/* optional element of type ns1:DiagEx */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (171)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (172)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (174)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (177)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (178)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
